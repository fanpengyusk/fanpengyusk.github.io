<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>范鹏宇</title>
  
  <subtitle>尚未执佩剑，转眼即江湖</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fanpengyusk.github.io/"/>
  <updated>2020-07-16T13:51:06.048Z</updated>
  <id>https://fanpengyusk.github.io/</id>
  
  <author>
    <name>fanpengyusk</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GCC中的aligned和packed属性</title>
    <link href="https://fanpengyusk.github.io/posts/dbfcf40b/"/>
    <id>https://fanpengyusk.github.io/posts/dbfcf40b/</id>
    <published>2020-07-16T13:30:43.000Z</published>
    <updated>2020-07-16T13:51:06.048Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>GCC中的aligned和packed属性</p></blockquote><a id="more"></a><h2 id="GCC中的aligned和packed属性"><a href="#GCC中的aligned和packed属性" class="headerlink" title="GCC中的aligned和packed属性"></a>GCC中的aligned和packed属性</h2><p>GCC支持用<strong>attribute</strong>为变量、类型、函数、标签指定特殊属性。这些不是编程语言标准里的内容，而属于编译器对语言的扩展。 本文介绍其中的两个属性：aligned和packed。<strong>aligned</strong>属性最常用在变量声明上。它的作用是告诉GCC，为变量分配内存时，要分配在对齐的内存地址上。</p><h3 id="什么是对齐的内存地址呢？"><a href="#什么是对齐的内存地址呢？" class="headerlink" title="什么是对齐的内存地址呢？"></a>什么是对齐的内存地址呢？</h3><p>一般计算机的内存是以字节（byte，等于8bit）为最小单元的。内存地址相当于从0开始的字节偏移数。如果一个内存地址是N的倍数，我们就说它是N字节对齐的（N-byte aligned）。 对于C/C++中的基本数据类型，假设它的长度为n字节，那么该类型的变量会被编译器默认分配到n字节对齐的内存上。例如，char的长度是1字节，char类型变量的地址将是1字节对齐的（任意值均可）； int的长度是4字节，所以int类型变量将被分配到4字节对齐的地址上。这种默认情况下的变量对齐方式又称作自然对齐（naturally aligned）。</p><p>但是，有时候我们希望改变这种默认情况。这时候就可以使用aligned属性了。例如：</p><p><code>int x __attribute__ ((aligned (16))) = 0;</code></p><p>告诉编译器把变量x分配在16字节对齐的内存地址上，而非默认的4字节对齐。编译器之所以默认让变量自然对齐，是因为这种对齐情况下的内存访问是最高效的。受限于硬件实现，非对齐内存访问的性能会有所下降；甚至在有些处理器（如DSP、早期的ARM）上，非对齐的内存访问根本就不支持， 将直接引发错误。而我们之所以需要自己指定对齐方式，很多时候是程序优化的需求。例如，在x86平台上要使用SSE指令，所操作的数据在内存中就必须是16字节对齐的。</p><p>aligned不仅可以用作变量属性，还能用作函数属性和数据类型属性。它作为函数属性时的作用等价于对函数使用-falign-functions这一优化选项。 当它用作数据类型的属性时，相当于告诉编译器，这一类型的所有变量都要按指定字节数对齐。</p><h3 id="aligned与结构体"><a href="#aligned与结构体" class="headerlink" title="aligned与结构体"></a>aligned与结构体</h3><p>结构体是一种数据类型，它与aligned有一些特殊的关系。上面提到，aligned可以用于指定数据类型的属性，因此可以用于结构体，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct  my_struct1 &#123;</span><br><span class="line">short f[3];</span><br><span class="line">&#125;__attribute__ ((aligned (8)));</span><br></pre></td></tr></table></figure><p>但这么用不仅会影响为该结构体变量分配内存的位置，还可能影响其内存占用。在上面的例子中，这个结构体内有3个两字节的short，本来只需要占用6字节的内存； 但由于指定了8字节对齐，编译器会在该结构体尾部填充额外的2个字节，使得这个结构体的大小为8字节。为什么要填充多余的字节呢？因为只有将该结构体补足8个字节，才能保证在这个结构体类型的数组中，数组中每个元素 都是8字节对齐的（考虑到数组元素在内存中的连续存放）。</p><p>aligned也可以用在结构体的成员上，这时就成了对变量指定属性。GCC的相关文档里提到，==C语言规定结构体类型必须至少对齐到其所有成员变量对齐字节数的最小公倍数， 因此指定结构体的对齐完全可以通过指定其中成员变量的对齐来实现，不过前者明显可读性好些==。</p><p>当aligned属性用于数据类型（比如结构体）的时候，只能增加对齐字节数而不能减小。例如，下面的结构体本身大小有6字节，虽然指定了4字节对齐，但并不能达到目的，最终GCC还是会按8字节对齐处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">my_struct2</span> &#123;</span></span><br><span class="line">short f[<span class="number">3</span>];</span><br><span class="line">&#125;__attribute__ ((aligned (<span class="number">4</span>)));</span><br></pre></td></tr></table></figure><p>linux内核中使用aligned的例子，在大部分平台上，cacheline为64字节，内核在频繁访问的字段或者带有锁的字段一般会保证cacheline对齐，例如如下数据结构，mem字段为原子变量，所以该变量的地址是cacheline对齐的，本身struct fqdir结构体也会cacheline对齐</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Per netns frag queues directory */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fqdir</span> &#123;</span></span><br><span class="line"><span class="comment">/* sysctls */</span></span><br><span class="line"><span class="keyword">long</span>high_thresh;</span><br><span class="line"><span class="keyword">long</span>low_thresh;</span><br><span class="line"><span class="keyword">int</span>timeout;</span><br><span class="line"><span class="keyword">int</span>max_dist;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_frags</span>*<span class="title">f</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span>*<span class="title">net</span>;</span></span><br><span class="line"><span class="keyword">bool</span>dead;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rhashtable</span>       <span class="title">rhashtable</span> ____<span class="title">cacheline_aligned_in_smp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Keep atomic mem on separate cachelines in structs that include it */</span></span><br><span class="line"><span class="keyword">atomic_long_t</span>mem ____cacheline_aligned_in_smp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span><span class="title">destroy_work</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果要减小对齐字节数，需要用到下面介绍的packed属性。</p><h3 id="packed"><a href="#packed" class="headerlink" title="packed"></a>packed</h3><p>packed属性的主要目的是让编译器更紧凑地使用内存。当它用于变量时，告诉编译器该变量应该有尽可能小的对齐，也就是1字节对齐。当它用于结构体时 ，相当于给该结构体的每个成员加上了packed属性，这时该结构体将占用尽可能少的内存。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">my_struct3</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">&#125;__attribute__ ((packed));</span><br></pre></td></tr></table></figure><p>这个结构体被指定了packed，所以它的成员变量将是1字节对齐的，也就是说成员i将紧跟着成员c，从而使得该结构体的实际大小为5字节。 如果不指定packed，由于要满足成员i的4字节对齐要求（它是int型的），编译器将在成员c之后填充3个字节，使得这个结构体实际大小变为8字节。</p><p>采用packed属性虽然可以节省内存，但它会导致非对齐的内存访问。例如上述结构体的int型成员变量i，它的内存地址将不是4的倍数，访问它时就是非对齐访问。 当用.或-&gt;操作符存取结构体成员时，编译器会保证存取到正确的值；但如果用指针直接访问非对齐的成员变量，就只能指望处理器支持非对齐访问了，否则将会出错。 这也是很多人认为给结构体指定packed属性不太安全的原因。</p><h2 id="什么时候用packed"><a href="#什么时候用packed" class="headerlink" title="什么时候用packed"></a>什么时候用packed</h2><p>上面说到使用packed可能“不安全”，但为什么还要用呢？什么时候会需要它呢？</p><p>使用packed最重要的场合莫过于处理跟文件格式或网络协议有关的二进制数据了。这些格式或协议是不能容忍多余字节的，所以当用结构体表示其数据时，必须阻止编译器填充字节。 这正是packed的设计初衷。另外还可以用packed来节省内存，不过这是以牺牲性能为代价的，不是什么好方法。通过适当排列结构体成员的顺序可以使得需要填充的字节数尽可能少，这才是应该考虑的措施。</p><p>但正如前面所说，使用packed属性具有潜在的问题。如果一个结构体被packed了，尽量不要使用指向其内部成员变量的指针，除非你真的知道你在做什么。</p><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://blog.shengbin.me/posts/gcc-attribute-aligned-and-packed">https://blog.shengbin.me/posts/gcc-attribute-aligned-and-packed</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;GCC中的aligned和packed属性&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="linux内核" scheme="https://fanpengyusk.github.io/categories/linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="linux内核" scheme="https://fanpengyusk.github.io/tags/linux%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>docker使用</title>
    <link href="https://fanpengyusk.github.io/posts/4e8a0e45/"/>
    <id>https://fanpengyusk.github.io/posts/4e8a0e45/</id>
    <published>2020-05-24T09:56:43.000Z</published>
    <updated>2020-05-24T10:30:47.173Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>docket常用命令</p></blockquote><a id="more"></a><h1 id="docker使用"><a href="#docker使用" class="headerlink" title="docker使用"></a>docker使用</h1><h2 id="docker镜像"><a href="#docker镜像" class="headerlink" title="docker镜像"></a>docker镜像</h2><p>Docker 镜像相关命令</p><ul><li>查看镜像: 查看本地所有的镜像<br>docker images<br>docker images –q # 查看所用镜像的id</li><li>搜索镜像:从网络中查找需要的镜像<br>docker search 镜像名称</li><li>拉取镜像:从Docker仓库下载镜像到本地,镜像名称格式为 名称:版本号,如果版本号不指定则是最新的版本。如果不知道镜像版本,可以去docker hub 搜索对应镜像查看。<br>docker pull 镜像名称</li><li>删除镜像: 删除本地镜像<br>docker rmi 镜像id # 删除指定本地镜像<br>docker rmi <code>docker images -q</code> # 删除所有本地镜像</li></ul><h2 id="docker容器"><a href="#docker容器" class="headerlink" title="docker容器"></a>docker容器</h2><p>docker容器是镜像的实例，通过docker run创建容器，docker ps -x可以查看目前所有容器的状态<br>docker run 参数<br>参数说明:<br>-i:保持容器运行。通常与 -t 同时使用。加入it这两个参数后,容器创建后自动进入容器中,退出容器后,容器自动关闭。<br>-t:为容器重新分配一个伪输入终端,通常与 -i 同时使用。<br>-d:以守护(后台)模式运行容器。创建一个容器在后台运行,需要使用docker exec 进入容器。退出后,容器不会关闭。<br>-it 创建的容器一般称为交互式容器,-id 创建的容器一般称为守护式容器<br>–name:为创建的容器命名</p><ul><li>进入容器<br>docker exec 参数 # 退出容器,容器不会关闭</li><li>停止容器<br>docker stop 容器名称</li><li>启动容器<br>docker start 容器名称</li><li>删除容器:如果容器是运行状态则删除失败,需要停止容器才能删除<br>docker rm 容器名称</li><li>查看容器信息<br>docker inspect 容器名称</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;docket常用命令&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="其他" scheme="https://fanpengyusk.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="linux应用 - 其他" scheme="https://fanpengyusk.github.io/tags/linux%E5%BA%94%E7%94%A8-%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>http服务器搭建</title>
    <link href="https://fanpengyusk.github.io/posts/47c45f64/"/>
    <id>https://fanpengyusk.github.io/posts/47c45f64/</id>
    <published>2020-05-24T09:30:43.000Z</published>
    <updated>2020-05-24T10:29:26.964Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>http服务器搭建</p></blockquote><a id="more"></a><h2 id="http服务器搭建"><a href="#http服务器搭建" class="headerlink" title="http服务器搭建"></a>http服务器搭建</h2><p>EasyEngine 相当好用，它内置了 NGINX 和 Let’s Encrypt，不用再单独安装nginx并申请证书，所以今次就利用它来架前端吧。</p><h3 id="安装-EasyEngine"><a href="#安装-EasyEngine" class="headerlink" title="安装 EasyEngine"></a>安装 EasyEngine</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO ee rt.cx/ee &amp;&amp; sudo bash ee</span><br></pre></td></tr></table></figure><p>中途会问你名字和 email，输入相关信息就可以。完成 setup 后，可以输入以下指令来令 EasyEngine 方便使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/bash_completion.d/ee_auto.rc</span><br></pre></td></tr></table></figure><p>easyengine finished setup完成安装后执行多说明里那一行指令会令设定更加顺利</p><h3 id="设置NGINX"><a href="#设置NGINX" class="headerlink" title="设置NGINX"></a>设置NGINX</h3><p>现在，可以首先设定前端的 NGINX，因为需要使用 SSL，所以亦要建立相关的 cert.<br>我们只需要 NGINX 和 Let’s Encrypt 就可以，所以不需要安装其他套件如 PHP 和 MySQL.<br>输入以下指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ee site create example.com --html --letsencrypt</span><br></pre></td></tr></table></figure><p>留意大家需要将 <strong>example.com</strong> 替换成你申请的 domain，今次示范为例，应该将 example.com 换成 youyipi.xyz</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ee site create youyipi.xyz --html --letsencrypt</span><br></pre></td></tr></table></figure><p>easyegnine site create ssl cert<br>成功建立网站+SSL 证书<br>Let’s Encrypt 需要每 90 天更新一次，不过 Easyeninge 已经设定了自动更新，所以不用担心。</p><h3 id="出错问题解决"><a href="#出错问题解决" class="headerlink" title="出错问题解决"></a>出错问题解决</h3><p>中间可能出现问题，一般根据log信息可以查到问题所在，如果 Let’s Encrypt 失败了的话，可以看这两个 log file，ee.log 是简单一些，letsencrypt.log 则详细一些cat /var/log/ee/ee.log 或 cat /var/log/letsencrypt/letsencrypt.log</p><p>我出现的问题是nginx无法启动，查看nginx的error信息是的nginx.conf有语法错误，删除有误的nginx.conf配置，重启nginx,并查看nginx是否在 active (running)状态，这一步一定要确保nginx运行起来，当nginx成功运行后，继续申请证书直到成功为止</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx</span><br><span class="line">systemctl status nginx</span><br><span class="line">ee site create youyipi.xyz --html --letsencrypt</span><br></pre></td></tr></table></figure><h3 id="布置html页面"><a href="#布置html页面" class="headerlink" title="布置html页面"></a>布置html页面</h3><p>到这一步，恭喜你的你的https服务器已经基本设置完成，只需要将你的html网页存放到指定目录，修改nginx可访问的权限即可，存放路径可以在 /etc/nginx/sites-enabled/example.com中修改，example.com为你的domain</p><p>默认html存放路径为/var/www/example.com/htdocs/index.html。修改html访问权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R www-data: /var/www/example.com/htdocs/</span><br></pre></td></tr></table></figure><h3 id="NOTE："><a href="#NOTE：" class="headerlink" title="NOTE："></a>NOTE：</h3><p>如果需要nginx反向代理v2ray，修改配置文件/var/www/example.com/conf/nginx/v2ray.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;enterv2ray&#x2F; &#123;</span><br><span class="line">proxy_redirect off;</span><br><span class="line">proxy_pass http:&#x2F;&#x2F;127.0.0.1:11054;</span><br><span class="line">proxy_http_version 1.1;</span><br><span class="line">proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">proxy_set_header Host $http_host;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>端口号11054需要根据自己v2ray的做修改</p><p>之后大家重新启动 NGINX</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="https://enterpr1se.info/2017/10/v2ray-gfw-setup/">https://enterpr1se.info/2017/10/v2ray-gfw-setup/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;http服务器搭建&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="linux应用" scheme="https://fanpengyusk.github.io/categories/linux%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="linux应用" scheme="https://fanpengyusk.github.io/tags/linux%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>linux网卡命名</title>
    <link href="https://fanpengyusk.github.io/posts/f047182b/"/>
    <id>https://fanpengyusk.github.io/posts/f047182b/</id>
    <published>2020-05-24T09:30:43.000Z</published>
    <updated>2020-05-24T10:29:10.981Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>linux网卡命名</p></blockquote><a id="more"></a><h1 id="Linux网卡命名规则"><a href="#Linux网卡命名规则" class="headerlink" title="Linux网卡命名规则"></a>Linux网卡命名规则</h1><p>传统的 Linux 下面看到的网卡名称都是从 eth0, eth1, eth2 …. 一直连续下去,一般我们使用的电脑只有 1 , 2 个网卡,所以在使用上不会遇到太大的难题,但是在多个网卡就头大了,到底哪一个ethx 是对应到哪一个实体网卡.</p><p>还好现在有新的装置命名规则,目前看到有两种方式 Biosdevname &amp; net.ifnames</p><h2 id="Biosdevname"><a href="#Biosdevname" class="headerlink" title="Biosdevname"></a>Biosdevname</h2><p>在讨论 Biosdevname 这种一致性的网络设备命名规则 device naming rule ,我们先来看看什么是 udev.<br>Linux 内核 2.6.15 之后的版本采用 sysfs 取代过去的 devfs ,我们就不需要像是传统的 Linux 把所有设备存放在 /dev/ 目录下(不管是不是会用到先通通产生),sysfs 多了一个 /sys/ 的目录存放动态设备节点 udev (sysfs), 优点是 /dev/ 不再需要预先产生很多不必要的设备.当有需要时系统再自行产生. udev 还提供了自己的规则来命名设备. 关于更多 udev 请自行参考 <a href="http://benjr.tw/10632">http://benjr.tw/10632</a></p><p>但老实说这还是很麻烦, Dell 戴尔开发了一个 udev 的协助工具 <strong>Biosdevname</strong>,这是一个以 GNU General Public License（GPL）下所开发的工具,它提供了一个一致性的命名机制,实体网卡的名称会依据 BIOS 所建议的方式来命名,命名规则大致如下.</p><ul><li><p>Embedded network interface (LOM)<br>em[1234…] ⁠[New enumeration starts at 1]</p></li><li><p>PCI card network interface<br>p[slot]p[ethernet port] ⁠[For example: p3p4]</p></li><li><p>Virtual function<br>p[slot]p[ethernet port]_ ⁠[For example: p3p4_1]</p></li></ul><p><strong>biosdevname</strong> 会依据系统的<a href="http://benjr.tw/214">SMBIOS</a>来为你的设备命名,不过系统的 BIOS 须为 SMBIOS 2.6 版本或是更高,当然如果你要使用此功能,必须使用 root 身份使用 yum 来安装 biosdevname 套件.</p><ul><li>RHEL (RedHat)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">＃yum install biosdevname</span><br></pre></td></tr></table></figure><p>接着在 Kernel 加入参数 biosdevname=1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#vi /boot/grub/grub.conf</span></span><br><span class="line">kernel /boot/vmlinuz biosdevname=1</span><br><span class="line">initrd /boot/initrd.img</span><br></pre></td></tr></table></figure><p>如果系统使用的是 GRUB2 ,要修改的档案为 /etc/default/grub 内的 GRUB_CMDLINE_LINUX .请参考 <a href="http://benjr.tw/95009">GRUB2</a></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat /etc/default/grub</span></span><br><span class="line">GRUB_TIMEOUT=5</span><br><span class="line">GRUB_DISTRIBUTOR=<span class="string">"<span class="variable">$(sed 's, release .*$,,g' /etc/system-release)</span>"</span></span><br><span class="line">GRUB_DEFAULT=saved</span><br><span class="line">GRUB_DISABLE_SUBMENU=<span class="literal">true</span></span><br><span class="line">GRUB_TERMINAL_OUTPUT=<span class="string">"console"</span></span><br><span class="line">GRUB_CMDLINE_LINUX=<span class="string">"crashkernel=auto rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet net.ifnames=0 biosdevname=0"</span></span><br><span class="line">GRUB_DISABLE_RECOVERY=<span class="string">"true"</span></span><br><span class="line">[root@localhost ~]<span class="comment"># grub2-mkconfig</span></span><br></pre></td></tr></table></figure><ul><li>Ubuntu</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">＃yum install biosdevname</span><br></pre></td></tr></table></figure><p>一样在 append 加入参数 biosdevname=1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#vi /boot/grub/grub.conf</span></span><br><span class="line">kernel /boot/vmlinuz</span><br><span class="line">append initrd=/boot/initrd.img biosdevname=1</span><br></pre></td></tr></table></figure><p>如果要取消将 biosdevname=0 即可.</p><p>或者是手动更改 /etc/udev/rules.d/70-persistent-net.rules 改变其命名规则.下面示范列参考</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vi /etc/udev/rules.d/70-persistent-net.rules</span></span><br><span class="line"><span class="comment"># PCI device 0x14e4:0x1680 (tg3)</span></span><br><span class="line">ACTION==<span class="string">"add"</span>, SUBSYSTEM==<span class="string">"net"</span>, DRIVER==<span class="string">"tg3"</span>, ATTR&#123;address&#125;==<span class="string">"00:1A:64:22:04:83"</span>, NAME=<span class="string">"em1"</span></span><br></pre></td></tr></table></figure><p>只要修改 NAME 的部分,如果系统没有 /etc/udev/rules.d/70-persistent-net.rules 请自行创建.<br>这一篇就讨论到如何自行修改网路设备的命名规则. <a href="http://benjr.tw/10626">http://benjr.tw/10626</a></p><h2 id="net-ifnames"><a href="#net-ifnames" class="headerlink" title="net.ifnames"></a>net.ifnames</h2><p>要查 net.ifnames 请用这个关键字 Predictable Network Interface Names,这个是预设的功能,除非你在开机的时候加入内核参数 net.ifnames=0 ,前面介绍的 biosdevname 也就没有再用了,先来看看 Predictable Network Interface 的命名规则长怎样!!</p><p>装置名称由 <strong>装置类型 + 装置位置+数字</strong> 组成：</p><h5 id="装置类型"><a href="#装置类型" class="headerlink" title="装置类型"></a>装置类型</h5><ol><li>en for Ethernet,</li><li>wl for wireless LAN (WLAN),</li><li>ww for wireless wide area network (WWAN).</li></ol><h5 id="装置位置-数字"><a href="#装置位置-数字" class="headerlink" title="装置位置+数字"></a>装置位置+数字</h5><ul><li>o on-board device index number</li><li>s[f][d] hotplug slot index number</li><li>x MAC address</li><li>ps[f][d] PCI geographical location</li><li>ps[f][u][..][i] USB port number chain</li></ul><p>enp0s3 就代表 Ethernet ,PCI bus 0,slot 3</p><h2 id="Biosdevname-amp-net-ifnames"><a href="#Biosdevname-amp-net-ifnames" class="headerlink" title="Biosdevname &amp; net.ifnames"></a>Biosdevname &amp; net.ifnames</h2><p>问题来了,如果 Biosdevname &amp; net.ifnames 都用了,那名称会变成怎麽样!!!</p><ol><li>No parameters (net.ifnames 为预设): NIC identified as “enp5s2”.</li><li>Parameter biosdevname=0 (net.ifnames 为预设): NIC identified as “enp5s2”.</li><li>Parameter net.ifnames=0 (采用 biosdevname 规则): NIC identified as “em1”.</li><li>Parameter net.ifnames=0 AND biosdevname=0 (最传统的方式,eth0 eth1 傻傻分不清): NIC identified as “eth0”.</li></ol><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="http://benjr.tw/93340">Linux – Biosdevname &amp; net.ifnames</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;linux网卡命名&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="linux应用" scheme="https://fanpengyusk.github.io/categories/linux%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="linux应用" scheme="https://fanpengyusk.github.io/tags/linux%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>git推送到vps</title>
    <link href="https://fanpengyusk.github.io/posts/1a54ada2/"/>
    <id>https://fanpengyusk.github.io/posts/1a54ada2/</id>
    <published>2020-05-24T08:10:00.000Z</published>
    <updated>2020-05-24T11:19:55.042Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>git推送到vps</p></blockquote><a id="more"></a><h3 id="本地操作"><a href="#本地操作" class="headerlink" title="本地操作"></a>本地操作</h3><ul><li>安装git</li><li>生成ssh密钥</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"yourname"</span></span><br><span class="line">git config --global user.email youremail@example.com</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"youremail@example.com</span></span><br></pre></td></tr></table></figure><p>最后生成的ssh密钥在~/.ssh/中</p><h3 id="VPS操作"><a href="#VPS操作" class="headerlink" title="VPS操作"></a>VPS操作</h3><ul><li>安装并配置Git</li></ul><p>安装后您可能想要做的第一件事是在Git中配置自己的名称和电子邮件地址，以便您提交的更改包含正确的信息。 您可以通过使用以下命令来完成此操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure><ul><li>创建git用户并切换到git用户</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adduser git</span><br><span class="line">su git</span><br></pre></td></tr></table></figure><p>根据提示填写内容。这步很重要，不切换用户后面需要手动修改文件的拥有者与组</p><ul><li>创建仓库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;var&#x2F;www&#x2F;</span><br><span class="line">mkdir repos</span><br><span class="line">git init --bare repos.git</span><br></pre></td></tr></table></figure><ul><li>添加钩子函数</li></ul><p>钩子函数在push文件后执行checkout</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd blog.git&#x2F;hooks</span><br><span class="line">vi post-receive</span><br><span class="line">chmod +x post-receive</span><br></pre></td></tr></table></figure><p>post-receive内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">git --work-tree&#x3D;&#x2F;var&#x2F;www&#x2F;repos --git-dir&#x3D;&#x2F;var&#x2F;www&#x2F;repos.git checkout -f</span><br></pre></td></tr></table></figure><p>测试git仓库是否可用，在本地机器另找空白文件夹，执行如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@server_ip:&#x2F;var&#x2F;www&#x2F;repos.git</span><br></pre></td></tr></table></figure><p>clone没有报错，提示clone到空的resp</p><ul><li>建立本地与vps ssh信任关系</li></ul><p>将本地的公钥复制到vps的authorized_keys文件里(公钥即上文中本地执行cat ~/.ssh/id_rsa.pub查看的内容)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">su git</span><br><span class="line">cd ~</span><br><span class="line">mkdir .ssh &amp;&amp; cd .ssh</span><br><span class="line">vim authorized_keys</span><br></pre></td></tr></table></figure><h3 id="push本地文件"><a href="#push本地文件" class="headerlink" title="push本地文件"></a>push本地文件</h3><p>经过上述步骤后，可以将本地文件push到vps中，以hugo为例，进入publish目录，初始化git仓库，操作如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd publish</span><br><span class="line">git init</span><br><span class="line">git add -A</span><br><span class="line">git commit -m &quot;building site&quot;</span><br><span class="line">git remote add origin git@server_ip:&#x2F;var&#x2F;www&#x2F;repos.git</span><br><span class="line">git push --set-upstream origin master</span><br></pre></td></tr></table></figure><p>修改本地文件后，可以使用脚本一键push</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">echo -e &quot;\033[0;32mDeploying updates to VPS...\033[0m&quot;</span><br><span class="line"></span><br><span class="line"># Build the project.</span><br><span class="line">cd exampleSite</span><br><span class="line">hugo # if using a theme, replace by &#96;hugo -t &lt;yourtheme&gt;&#96;</span><br><span class="line"></span><br><span class="line"># Go To Public folder</span><br><span class="line">cd public</span><br><span class="line"># Add changes to git.</span><br><span class="line"></span><br><span class="line">git add -A</span><br><span class="line"></span><br><span class="line"># Commit changes.</span><br><span class="line">msg&#x3D;&quot;rebuilding site &#96;date&#96;&quot;</span><br><span class="line"></span><br><span class="line">if [ $# -eq 1 ]; then</span><br><span class="line">msg&#x3D;&quot;$1&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">git commit -m &quot;$msg&quot;</span><br><span class="line"></span><br><span class="line"># Push source and build repos.</span><br><span class="line">git push origin master</span><br><span class="line"></span><br><span class="line"># Come Back</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure><h3 id="note"><a href="#note" class="headerlink" title="note:"></a>note:</h3><p>从本地git push到vps中的文件owner与group都是上文中创建的git用户，需要确保nginx有权限访问这些html文件，可以将nginx worker用户与git放到一个组，设置文件组访问权限</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.jianshu.com/p/d1f7cfb8ecf0">https://www.jianshu.com/p/d1f7cfb8ecf0</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;git推送到vps&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="git" scheme="https://fanpengyusk.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://fanpengyusk.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>加密文章测试</title>
    <link href="https://fanpengyusk.github.io/posts/7e709353/"/>
    <id>https://fanpengyusk.github.io/posts/7e709353/</id>
    <published>2020-01-21T02:14:11.000Z</published>
    <updated>2020-05-23T10:28:24.862Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="不好意思，密码没对哦，在检查检查呢！" data-whm="不好意思，信息无法验证！">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">嗨，请准确无误地输入密码查看哟（密码：123456）！</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="7c9df5696499b0943b0714a90278edc9cdb12f7962c2949648214eee27e824eb">42401e656a30ed09e8e3b0fbe2fbd18ae1b8c2138de0b629bd1233cbc0cc80918b020088b54c79621b8ef9a9af7b0f06b4f358e8c86ef99d097fb161589581b453752da7da2e21aa4d35b94c835c62d1204ab327d5d9241d6be3c6b4b1e68d3697229826ffa52b53920e92cbe496af209269f803aa7450ba136338b0e891ba54f6fe48d0d23c1ba5b981305fdee3badd054b7ad20712af650adf010b25c3fa117b769979c2ef7a2ccccee14b24ed84530b911e7b68c43d9f4592ba8687b2c7fb</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      咦，这是一篇加密文章，好像需要输入密码才能查看呢！
    
    </summary>
    
    
      <category term="private" scheme="https://fanpengyusk.github.io/categories/private/"/>
    
    
      <category term="加密文章" scheme="https://fanpengyusk.github.io/tags/%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
</feed>
