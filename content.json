{"pages":[{"title":"","text":"唐艺昕 李沁 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"","text":"个人简介 -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息： 博客信息 2019.12.31 2018.12.31/21:59:00-&gt;更新于2019.12.31 时间轴记录","link":"/about/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://github.com/fanpengyusk/blog_image/blob/master/img/hexo/head.jpg 网站名称：范鹏宇blog 网站地址：https://fanpengyusk.github.io 网站简介：内核开发，技术分享 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 var gitalk = new Gitalk({ clientID: '46a9f3481b46ea0129d8', clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24', id: '666666', repo: 'issue_database', owner: 'removeif', admin: \"removeif\", createIssueManually: true, distractionFreeMode: false }) gitalk.render('comment-container1')","link":"/self-talking/index.html"},{"title":"音乐歌单收藏","text":"--- 温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"}],"posts":[{"title":"http服务器搭建","text":"http服务器搭建 http服务器搭建EasyEngine 相当好用，它内置了 NGINX 和 Let’s Encrypt，不用再单独安装nginx并申请证书，所以今次就利用它来架前端吧。 安装 EasyEngine1wget -qO ee rt.cx/ee &amp;&amp; sudo bash ee 中途会问你名字和 email，输入相关信息就可以。完成 setup 后，可以输入以下指令来令 EasyEngine 方便使用 1source /etc/bash_completion.d/ee_auto.rc easyengine finished setup完成安装后执行多说明里那一行指令会令设定更加顺利 设置NGINX现在，可以首先设定前端的 NGINX，因为需要使用 SSL，所以亦要建立相关的 cert.我们只需要 NGINX 和 Let’s Encrypt 就可以，所以不需要安装其他套件如 PHP 和 MySQL.输入以下指令 1ee site create example.com --html --letsencrypt 留意大家需要将 example.com 替换成你申请的 domain，今次示范为例，应该将 example.com 换成 youyipi.xyz 1ee site create youyipi.xyz --html --letsencrypt easyegnine site create ssl cert成功建立网站+SSL 证书Let’s Encrypt 需要每 90 天更新一次，不过 Easyeninge 已经设定了自动更新，所以不用担心。 出错问题解决中间可能出现问题，一般根据log信息可以查到问题所在，如果 Let’s Encrypt 失败了的话，可以看这两个 log file，ee.log 是简单一些，letsencrypt.log 则详细一些cat /var/log/ee/ee.log 或 cat /var/log/letsencrypt/letsencrypt.log 我出现的问题是nginx无法启动，查看nginx的error信息是的nginx.conf有语法错误，删除有误的nginx.conf配置，重启nginx,并查看nginx是否在 active (running)状态，这一步一定要确保nginx运行起来，当nginx成功运行后，继续申请证书直到成功为止 123systemctl restart nginxsystemctl status nginxee site create youyipi.xyz --html --letsencrypt 布置html页面到这一步，恭喜你的你的https服务器已经基本设置完成，只需要将你的html网页存放到指定目录，修改nginx可访问的权限即可，存放路径可以在 /etc/nginx/sites-enabled/example.com中修改，example.com为你的domain 默认html存放路径为/var/www/example.com/htdocs/index.html。修改html访问权限 1chown -R www-data: /var/www/example.com/htdocs/ NOTE：如果需要nginx反向代理v2ray，修改配置文件/var/www/example.com/conf/nginx/v2ray.conf 12345678location /enterv2ray/ { proxy_redirect off; proxy_pass http://127.0.0.1:11054; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_set_header Host $http_host;} 端口号11054需要根据自己v2ray的做修改 之后大家重新启动 NGINX 1systemctl restart nginx 参考链接：https://enterpr1se.info/2017/10/v2ray-gfw-setup/","link":"/posts/47c45f64/"},{"title":"git推送到vps","text":"git推送到vps 本地操作 安装git 生成ssh密钥 123git config --global user.name \"yourname\"git config --global user.email youremail@example.comssh-keygen -t rsa -C \"youremail@example.com 最后生成的ssh密钥在~/.ssh/中 VPS操作 安装并配置Git 安装后您可能想要做的第一件事是在Git中配置自己的名称和电子邮件地址，以便您提交的更改包含正确的信息。 您可以通过使用以下命令来完成此操作： 12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail@example.com&quot; 创建git用户并切换到git用户 12adduser gitsu git 根据提示填写内容。这步很重要，不切换用户后面需要手动修改文件的拥有者与组 创建仓库 123cd /var/www/mkdir reposgit init --bare repos.git 添加钩子函数 钩子函数在push文件后执行checkout 123cd blog.git/hooksvi post-receivechmod +x post-receive post-receive内容如下 12#!/bin/shgit --work-tree=/var/www/repos --git-dir=/var/www/repos.git checkout -f 测试git仓库是否可用，在本地机器另找空白文件夹，执行如下命令 1git clone git@server_ip:/var/www/repos.git clone没有报错，提示clone到空的resp 建立本地与vps ssh信任关系 将本地的公钥复制到vps的authorized_keys文件里(公钥即上文中本地执行cat ~/.ssh/id_rsa.pub查看的内容) 1234su gitcd ~mkdir .ssh &amp;&amp; cd .sshvim authorized_keys push本地文件经过上述步骤后，可以将本地文件push到vps中，以hugo为例，进入publish目录，初始化git仓库，操作如下 123456cd publishgit initgit add -Agit commit -m &quot;building site&quot;git remote add origin git@server_ip:/var/www/repos.gitgit push --set-upstream origin master 修改本地文件后，可以使用脚本一键push 12345678910111213141516171819202122232425262728#!/bin/bashecho -e &quot;\\033[0;32mDeploying updates to VPS...\\033[0m&quot;# Build the project.cd exampleSitehugo # if using a theme, replace by `hugo -t &lt;yourtheme&gt;`# Go To Public foldercd public# Add changes to git.git add -A# Commit changes.msg=&quot;rebuilding site `date`&quot;if [ $# -eq 1 ]; then msg=&quot;$1&quot;figit commit -m &quot;$msg&quot;# Push source and build repos.git push origin master# Come Backcd .. note:从本地git push到vps中的文件owner与group都是上文中创建的git用户，需要确保nginx有权限访问这些html文件，可以将nginx worker用户与git放到一个组，设置文件组访问权限 参考链接https://www.jianshu.com/p/d1f7cfb8ecf0","link":"/posts/1a54ada2/"},{"title":"linux网卡命名","text":"linux网卡命名 Linux网卡命名规则传统的 Linux 下面看到的网卡名称都是从 eth0, eth1, eth2 …. 一直连续下去,一般我们使用的电脑只有 1 , 2 个网卡,所以在使用上不会遇到太大的难题,但是在多个网卡就头大了,到底哪一个ethx 是对应到哪一个实体网卡. 还好现在有新的装置命名规则,目前看到有两种方式 Biosdevname &amp; net.ifnames Biosdevname在讨论 Biosdevname 这种一致性的网络设备命名规则 device naming rule ,我们先来看看什么是 udev.Linux 内核 2.6.15 之后的版本采用 sysfs 取代过去的 devfs ,我们就不需要像是传统的 Linux 把所有设备存放在 /dev/ 目录下(不管是不是会用到先通通产生),sysfs 多了一个 /sys/ 的目录存放动态设备节点 udev (sysfs), 优点是 /dev/ 不再需要预先产生很多不必要的设备.当有需要时系统再自行产生. udev 还提供了自己的规则来命名设备. 关于更多 udev 请自行参考 http://benjr.tw/10632 但老实说这还是很麻烦, Dell 戴尔开发了一个 udev 的协助工具 Biosdevname,这是一个以 GNU General Public License（GPL）下所开发的工具,它提供了一个一致性的命名机制,实体网卡的名称会依据 BIOS 所建议的方式来命名,命名规则大致如下. Embedded network interface (LOM)em[1234…] ⁠[New enumeration starts at 1] PCI card network interfacep[slot]p[ethernet port] ⁠[For example: p3p4] Virtual functionp[slot]p[ethernet port]_ ⁠[For example: p3p4_1] biosdevname 会依据系统的SMBIOS来为你的设备命名,不过系统的 BIOS 须为 SMBIOS 2.6 版本或是更高,当然如果你要使用此功能,必须使用 root 身份使用 yum 来安装 biosdevname 套件. RHEL (RedHat) 1＃yum install biosdevname 接着在 Kernel 加入参数 biosdevname=1 123#vi /boot/grub/grub.confkernel /boot/vmlinuz biosdevname=1initrd /boot/initrd.img 如果系统使用的是 GRUB2 ,要修改的档案为 /etc/default/grub 内的 GRUB_CMDLINE_LINUX .请参考 GRUB2 123456789[root@localhost ~]# cat /etc/default/grubGRUB_TIMEOUT=5GRUB_DISTRIBUTOR=\"$(sed 's, release .*$,,g' /etc/system-release)\"GRUB_DEFAULT=savedGRUB_DISABLE_SUBMENU=trueGRUB_TERMINAL_OUTPUT=\"console\"GRUB_CMDLINE_LINUX=\"crashkernel=auto rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet net.ifnames=0 biosdevname=0\"GRUB_DISABLE_RECOVERY=\"true\"[root@localhost ~]# grub2-mkconfig Ubuntu 1＃yum install biosdevname 一样在 append 加入参数 biosdevname=1 123#vi /boot/grub/grub.confkernel /boot/vmlinuzappend initrd=/boot/initrd.img biosdevname=1 如果要取消将 biosdevname=0 即可. 或者是手动更改 /etc/udev/rules.d/70-persistent-net.rules 改变其命名规则.下面示范列参考 123# vi /etc/udev/rules.d/70-persistent-net.rules# PCI device 0x14e4:0x1680 (tg3)ACTION==\"add\", SUBSYSTEM==\"net\", DRIVER==\"tg3\", ATTR{address}==\"00:1A:64:22:04:83\", NAME=\"em1\" 只要修改 NAME 的部分,如果系统没有 /etc/udev/rules.d/70-persistent-net.rules 请自行创建.这一篇就讨论到如何自行修改网路设备的命名规则. http://benjr.tw/10626 net.ifnames要查 net.ifnames 请用这个关键字 Predictable Network Interface Names,这个是预设的功能,除非你在开机的时候加入内核参数 net.ifnames=0 ,前面介绍的 biosdevname 也就没有再用了,先来看看 Predictable Network Interface 的命名规则长怎样!! 装置名称由 装置类型 + 装置位置+数字 组成： 装置类型 en for Ethernet, wl for wireless LAN (WLAN), ww for wireless wide area network (WWAN). 装置位置+数字 o on-board device index number s[f][d] hotplug slot index number x MAC address ps[f][d] PCI geographical location ps[f][u][..][i] USB port number chain enp0s3 就代表 Ethernet ,PCI bus 0,slot 3 Biosdevname &amp; net.ifnames问题来了,如果 Biosdevname &amp; net.ifnames 都用了,那名称会变成怎麽样!!! No parameters (net.ifnames 为预设): NIC identified as “enp5s2”. Parameter biosdevname=0 (net.ifnames 为预设): NIC identified as “enp5s2”. Parameter net.ifnames=0 (采用 biosdevname 规则): NIC identified as “em1”. Parameter net.ifnames=0 AND biosdevname=0 (最传统的方式,eth0 eth1 傻傻分不清): NIC identified as “eth0”. 参考：Linux – Biosdevname &amp; net.ifnames","link":"/posts/f047182b/"},{"title":"docker使用","text":"docket常用命令 docker使用docker镜像Docker 镜像相关命令 查看镜像: 查看本地所有的镜像docker imagesdocker images –q # 查看所用镜像的id 搜索镜像:从网络中查找需要的镜像docker search 镜像名称 拉取镜像:从Docker仓库下载镜像到本地,镜像名称格式为 名称:版本号,如果版本号不指定则是最新的版本。如果不知道镜像版本,可以去docker hub 搜索对应镜像查看。docker pull 镜像名称 删除镜像: 删除本地镜像docker rmi 镜像id # 删除指定本地镜像docker rmi docker images -q # 删除所有本地镜像 docker容器docker容器是镜像的实例，通过docker run创建容器，docker ps -x可以查看目前所有容器的状态docker run 参数参数说明:-i:保持容器运行。通常与 -t 同时使用。加入it这两个参数后,容器创建后自动进入容器中,退出容器后,容器自动关闭。-t:为容器重新分配一个伪输入终端,通常与 -i 同时使用。-d:以守护(后台)模式运行容器。创建一个容器在后台运行,需要使用docker exec 进入容器。退出后,容器不会关闭。-it 创建的容器一般称为交互式容器,-id 创建的容器一般称为守护式容器–name:为创建的容器命名 进入容器docker exec 参数 # 退出容器,容器不会关闭 停止容器docker stop 容器名称 启动容器docker start 容器名称 删除容器:如果容器是运行状态则删除失败,需要停止容器才能删除docker rm 容器名称 查看容器信息docker inspect 容器名称","link":"/posts/4e8a0e45/"},{"title":"加密文章测试","text":"嗨，请准确无误地输入密码查看哟（密码：123456）！ 42401e656a30ed09e8e3b0fbe2fbd18ae1b8c2138de0b629bd1233cbc0cc80918b020088b54c79621b8ef9a9af7b0f06b4f358e8c86ef99d097fb161589581b453752da7da2e21aa4d35b94c835c62d1204ab327d5d9241d6be3c6b4b1e68d3697229826ffa52b53920e92cbe496af209269f803aa7450ba136338b0e891ba54f6fe48d0d23c1ba5b981305fdee3badd054b7ad20712af650adf010b25c3fa117b769979c2ef7a2ccccee14b24ed84530b911e7b68c43d9f4592ba8687b2c7fb","link":"/posts/7e709353/"},{"title":"GCC中的aligned和packed属性","text":"GCC中的aligned和packed属性 GCC中的aligned和packed属性GCC支持用attribute为变量、类型、函数、标签指定特殊属性。这些不是编程语言标准里的内容，而属于编译器对语言的扩展。 本文介绍其中的两个属性：aligned和packed。aligned属性最常用在变量声明上。它的作用是告诉GCC，为变量分配内存时，要分配在对齐的内存地址上。 什么是对齐的内存地址呢？一般计算机的内存是以字节（byte，等于8bit）为最小单元的。内存地址相当于从0开始的字节偏移数。如果一个内存地址是N的倍数，我们就说它是N字节对齐的（N-byte aligned）。 对于C/C++中的基本数据类型，假设它的长度为n字节，那么该类型的变量会被编译器默认分配到n字节对齐的内存上。例如，char的长度是1字节，char类型变量的地址将是1字节对齐的（任意值均可）； int的长度是4字节，所以int类型变量将被分配到4字节对齐的地址上。这种默认情况下的变量对齐方式又称作自然对齐（naturally aligned）。 但是，有时候我们希望改变这种默认情况。这时候就可以使用aligned属性了。例如： int x __attribute__ ((aligned (16))) = 0; 告诉编译器把变量x分配在16字节对齐的内存地址上，而非默认的4字节对齐。编译器之所以默认让变量自然对齐，是因为这种对齐情况下的内存访问是最高效的。受限于硬件实现，非对齐内存访问的性能会有所下降；甚至在有些处理器（如DSP、早期的ARM）上，非对齐的内存访问根本就不支持， 将直接引发错误。而我们之所以需要自己指定对齐方式，很多时候是程序优化的需求。例如，在x86平台上要使用SSE指令，所操作的数据在内存中就必须是16字节对齐的。 aligned不仅可以用作变量属性，还能用作函数属性和数据类型属性。它作为函数属性时的作用等价于对函数使用-falign-functions这一优化选项。 当它用作数据类型的属性时，相当于告诉编译器，这一类型的所有变量都要按指定字节数对齐。 aligned与结构体结构体是一种数据类型，它与aligned有一些特殊的关系。上面提到，aligned可以用于指定数据类型的属性，因此可以用于结构体，例如： 123struct my_struct1 { short f[3];}__attribute__ ((aligned (8))); 但这么用不仅会影响为该结构体变量分配内存的位置，还可能影响其内存占用。在上面的例子中，这个结构体内有3个两字节的short，本来只需要占用6字节的内存； 但由于指定了8字节对齐，编译器会在该结构体尾部填充额外的2个字节，使得这个结构体的大小为8字节。为什么要填充多余的字节呢？因为只有将该结构体补足8个字节，才能保证在这个结构体类型的数组中，数组中每个元素 都是8字节对齐的（考虑到数组元素在内存中的连续存放）。 aligned也可以用在结构体的成员上，这时就成了对变量指定属性。GCC的相关文档里提到，==C语言规定结构体类型必须至少对齐到其所有成员变量对齐字节数的最小公倍数， 因此指定结构体的对齐完全可以通过指定其中成员变量的对齐来实现，不过前者明显可读性好些==。 当aligned属性用于数据类型（比如结构体）的时候，只能增加对齐字节数而不能减小。例如，下面的结构体本身大小有6字节，虽然指定了4字节对齐，但并不能达到目的，最终GCC还是会按8字节对齐处理。 123struct my_struct2 { short f[3];}__attribute__ ((aligned (4))); linux内核中使用aligned的例子，在大部分平台上，cacheline为64字节，内核在频繁访问的字段或者带有锁的字段一般会保证cacheline对齐，例如如下数据结构，mem字段为原子变量，所以该变量的地址是cacheline对齐的，本身struct fqdir结构体也会cacheline对齐 1234567891011121314151617/* Per netns frag queues directory */struct fqdir { /* sysctls */ long high_thresh; long low_thresh; int timeout; int max_dist; struct inet_frags *f; struct net *net; bool dead; struct rhashtable rhashtable ____cacheline_aligned_in_smp; /* Keep atomic mem on separate cachelines in structs that include it */ atomic_long_t mem ____cacheline_aligned_in_smp; struct work_struct destroy_work;}; 如果要减小对齐字节数，需要用到下面介绍的packed属性。 packedpacked属性的主要目的是让编译器更紧凑地使用内存。当它用于变量时，告诉编译器该变量应该有尽可能小的对齐，也就是1字节对齐。当它用于结构体时 ，相当于给该结构体的每个成员加上了packed属性，这时该结构体将占用尽可能少的内存。例如： 1234struct my_struct3 { char c; int i;}__attribute__ ((packed)); 这个结构体被指定了packed，所以它的成员变量将是1字节对齐的，也就是说成员i将紧跟着成员c，从而使得该结构体的实际大小为5字节。 如果不指定packed，由于要满足成员i的4字节对齐要求（它是int型的），编译器将在成员c之后填充3个字节，使得这个结构体实际大小变为8字节。 采用packed属性虽然可以节省内存，但它会导致非对齐的内存访问。例如上述结构体的int型成员变量i，它的内存地址将不是4的倍数，访问它时就是非对齐访问。 当用.或-&gt;操作符存取结构体成员时，编译器会保证存取到正确的值；但如果用指针直接访问非对齐的成员变量，就只能指望处理器支持非对齐访问了，否则将会出错。 这也是很多人认为给结构体指定packed属性不太安全的原因。 什么时候用packed上面说到使用packed可能“不安全”，但为什么还要用呢？什么时候会需要它呢？ 使用packed最重要的场合莫过于处理跟文件格式或网络协议有关的二进制数据了。这些格式或协议是不能容忍多余字节的，所以当用结构体表示其数据时，必须阻止编译器填充字节。 这正是packed的设计初衷。另外还可以用packed来节省内存，不过这是以牺牲性能为代价的，不是什么好方法。通过适当排列结构体成员的顺序可以使得需要填充的字节数尽可能少，这才是应该考虑的措施。 但正如前面所说，使用packed属性具有潜在的问题。如果一个结构体被packed了，尽量不要使用指向其内部成员变量的指针，除非你真的知道你在做什么。 参考链接：https://blog.shengbin.me/posts/gcc-attribute-aligned-and-packed","link":"/posts/dbfcf40b/"}],"tags":[{"name":"linux应用","slug":"linux应用","link":"/tags/linux%E5%BA%94%E7%94%A8/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"linux应用 - 其他","slug":"linux应用-其他","link":"/tags/linux%E5%BA%94%E7%94%A8-%E5%85%B6%E4%BB%96/"},{"name":"加密文章","slug":"加密文章","link":"/tags/%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0/"},{"name":"linux内核","slug":"linux内核","link":"/tags/linux%E5%86%85%E6%A0%B8/"}],"categories":[{"name":"linux应用","slug":"linux应用","link":"/categories/linux%E5%BA%94%E7%94%A8/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"},{"name":"private","slug":"private","link":"/categories/private/"},{"name":"linux内核","slug":"linux内核","link":"/categories/linux%E5%86%85%E6%A0%B8/"}]}